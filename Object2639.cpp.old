
// void Object2639::load() {
//     GLuint aa = glGenLists(1);
//     assert(aa != 0);

//     this->_displaylist = aa;

//     if (this->texturePath != NULL) {
//         this->_sprite = sprite_load(this->texturePath);
//         assert(this->_sprite != NULL);

//         glGenTextures(1, this->_texture);
//         glBindTexture(GL_TEXTURE_2D, this->_texture[0]);

//         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
//         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
//         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
//         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

//         surface_t surf = sprite_get_lod_pixels(this->_sprite, 0);
//         glTexImageN64(GL_TEXTURE_2D, 0, &surf);
//     }
//     glNewList(this->_displaylist, GL_COMPILE);
//     glBegin(GL_TRIANGLES);
//     for (u32 i = 0; i < this->segmentCount; i++) {
//         _processSegment(&this->modelList[i]);
//     }
//     glEnd();
//     glEndList();
// }



static __attribute__((unused)) void _processSegment(gtGfx *g) {
    gtState *gs = g->obj.statep;


    glBindBufferARB(GL_ARRAY_BUFFER_ARB, 0);
    glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);

    glEnableClientState(GL_VERTEX_ARRAY);
    glVertexPointer(3, GL_FLOAT, sizeof(Vtx), g->obj.vtxp);
    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
    glTexCoordPointer(2, GL_SHORT, sizeof(Vtx), g->obj.vtxp->v.tc);

    if (gs->sp.renderState & GT_TEXTURE) {
        glEnableClientState(GL_COLOR_ARRAY);
        glColorPointer(4, GL_UNSIGNED_BYTE, sizeof(Vtx), g->obj.vtxp->v.cn);
    } else {
        glEnableClientState(GL_NORMAL_ARRAY);
        glNormalPointer(GL_BYTE, sizeof(Vtx), g->obj.vtxp->v.cn);
    }

    GLubyte (*tris)[3] = g->obj.trip;
    glDrawElements(GL_TRIANGLES, gs->sp.triCount * 3, GL_UNSIGNED_BYTE, tris);
}
